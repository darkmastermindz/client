@namespace("keybase.1")
protocol phoneNumbers {
    import idl "common.avdl";

    // Phone number, possibly invalid
    @typedef("string")
    record RawPhoneNumber {}

    /**
     Phone number support for TOFU chats.
    */
    record UserPhoneNumber {
      @jsonkey("phone_number")
      PhoneNumber phoneNumber;
      @jsonkey("verified")
      boolean verified;
      @jsonkey("visibility")
      IdentityVisibility visibility;
      @jsonkey("ctime")
      UnixTime ctime;

    }
    record PhoneNumberLookupResult {
       @jsonkey("phone_number")
       RawPhoneNumber phoneNumber;
       @jsonkey("coerced_phone_number")
       PhoneNumber coercedPhoneNumber;
       @jsonkey("err")
       union { null, string } err;
       @jsonkey("uid")
       union { null, UID } uid;
    }

    void addPhoneNumber(int sessionID, PhoneNumber phoneNumber, IdentityVisibility visibility);
    void editPhoneNumber(int sessionID, PhoneNumber oldPhoneNumber, PhoneNumber phoneNumber, IdentityVisibility visibility);
    void verifyPhoneNumber(int sessionID, PhoneNumber phoneNumber, string code);
    array<UserPhoneNumber> getPhoneNumbers(int sessionID);
    void deletePhoneNumber(int sessionID, PhoneNumber phoneNumber);
    void setVisibilityPhoneNumber(int sessionID, PhoneNumber phoneNumber, IdentityVisibility visibility);
    void setVisibilityAllPhoneNumber(int sessionID, IdentityVisibility visibility);
    array<PhoneNumberLookupResult> bulkLookupPhoneNumbers(int sessionID, array<RawPhoneNumber> phoneNumberContacts, array<RegionCode> regionCodes, union { null, RegionCode } userRegionCode);

    record PhoneNumberAddedMsg {
        @jsonkey("phone")
        PhoneNumber phoneNumber;
    }

    record PhoneNumberVerifiedMsg {
        @jsonkey("phone")
        PhoneNumber phoneNumber;
    }

    record PhoneNumberSupersededMsg {
        @jsonkey("phone")
        PhoneNumber phoneNumber;
    }

    // Contact syncing / resolving
    // ---------------------------

    record ContactComponent {
        // One of:
        union { null, RawPhoneNumber } phoneNumber;
        union { null, EmailAddress } email;
        string label; // "", "Home", "Work"
    }
    record Contact {
        string name; // "Bob Goodman"
        array<ContactComponent> components;
    }
    record ResolvedContact {
        string name; // "Bob Goodman"
        ContactComponent component;

        // Outputs:
        union { null, string } err;
        boolean resolved;
        // If resolved:
        UID uid; // uid
        string username; // keybase username
        string fullName; // keybase full name
    }

    // lookupContactList transforms contact list (where every contact may have
    // multiple `components`, like phone numbers or email addresses) to a list
    // of (un)resolved contacts.
    //
    // If a contact finds a keybase resolution for any of its ContactComponents,
    // one ResolvedContact is returned with the contact name, ContactComponent
    // granting its resolution, and Keybase data.
    //
    // If a contact cannot be resolved for any of its component, each
    // ContactComponent is transformed into ResolvedContact and returned. They are
    // separate because each one can be used in the UI to allow for SBS chat.
    array<ResolvedContact> lookupContactList(int sessionID, array<Contact> contacts, RegionCode userRegionCode);
}
